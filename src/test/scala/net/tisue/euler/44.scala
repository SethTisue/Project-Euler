package net.tisue.euler

// Pentagonal numbers are generated by the formula, Pn=n(3n-1)/2. The first ten pentagonal numbers
// are 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
// Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference is pentagonal
// and D = |Pk - Pj| is minimised.  What is the value of D?

// Confession: I cheated on this one.  I wrote what I'm 99% sure was correct code for finding a
// solution, but it looked it was going to take a long time to run: hours? days? no way to know
// without knowing the size of the answer ahead of time.  So I Googled for a Haskell solution,
// converted it to Scala (that's the code below), and got the answer.  I estimate my old code would
// have found it in under an hour.

// In my defense, there is some question in my mind of whether the code below is really guaranteed
// to find the smallest answer, though, or whether it's just accidental that it works.  It finds the
// smallest Pk for the smallest Pj, but does that minimize Pk - Pj?  It seems conceivable to me that
// there might be some larger Pj for which there is a smaller D.  The approach I took could easily
// be seen to minimize D, and that's why it took longer to run.  See the problem forum for
// discussion of the issue, for example the posts from Technomage and Incandenza.  "IMHO it is
// somewhat of a flaw in the problem if you can easily get the right answer with an algorithm that
// is not technically correct."  What I don't know is whether there is any way to get the runtime
// under a minute while still doing the broader search.

class Problem44 extends Problem(44, "5482660"):
  def solve =
    def pentagonal(n: BigInt) = n * (n * 3 - 1) / 2
    val pstream = LazyList.from(1).map(n => pentagonal(BigInt(n)))
    val pset = pstream.take(5000).toSet
    def isPentagonal(n: BigInt) = pset.contains(n)
    (for a <- pstream;
         b <- pstream.takeWhile(_ < a)
         if isPentagonal(a + b)
         if isPentagonal(a - b)
     yield (a - b)).head
